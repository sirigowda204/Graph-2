// Time Complexity : O(N^2)
// Space Complexity : O(N)

class Solution {
  int[] colours;
  int colour;
  public int minMalwareSpread(int[][] graph, int[] initial) {
    if(graph == null || graph.length == 0) return -1;
    int n = graph.length;
    colours = new int[n];
    Arrays.fill(colours, -1);

    // 1. DFS to fill colours array - group identificaion
    for(int i = 0; i < n; i++) {
      if(colours[i] == -1) {
        dfs(graph, i);
        colour++;
      }
    }

    // 2. Creating group array - no. of nodes in each group
    int[] groups = new int[colour];
    for(int i = 0; i < n; i++) {
      groups[colours[i]]++;
    }

    // 3. Infected array - how many infected in each group
    int[] infected = new int[colour];
    for(int i = 0; i < initial.length; i++) {
      infected[colours[initial[i]]]++;
    }

    // 4. Getting the result node
    Arrays.sort(initial);
    int minimize = -1;
    int result = initial[0];
    for(int i = 0; i < initial.length; i++) {
      int group = colours[initial[i]];
      if(infected[group] == 1) {
        if(groups[group] > minimize) {
          minimize = groups[group];
          result = initial[i];
        }
      }
    }
    return result;
  }

  private void dfs(int[][] graph, int node) {
    // Base
    if(colours[node] != -1) return;
    // Action
    colours[node] = colour;
    // Recurse
    for(int i = 0; i<graph.length; i++) {
      if(graph[node][i] == 1 && colours[i] == -1) {
        dfs(graph, i);
      }
    }
  }
}